/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: Noss (https://sketchfab.com/Noss)
license: SKETCHFAB Standard (https://sketchfab.com/licenses)
source: https://sketchfab.com/models/2135f146d2964c22b5bfac3134c35191
title: Day 05 - Object : Spherical
*/

import React, { useCallback, useEffect, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import gsap from "gsap";
import { Text } from "@react-three/drei";
import { Box, Flex } from "@react-three/flex";
import fontUrl from "static/font/s.otf";

import {
  LinearToneMapping,
  NoToneMapping,
  ACESFilmicToneMapping,
  ReinhardToneMapping,
  CineonToneMapping,
} from "three";
import { useThree } from "@react-three/fiber";
const TONEMAPPING_DIC = {
  NoToneMapping,
  LinearToneMapping,
  ACESFilmicToneMapping,
  ReinhardToneMapping,
  CineonToneMapping,
};

const MOVE_DURATION = 0.8;
export default function Model({ ...props }) {
  const sceneGroup = useRef();
  const { viewport } = useThree();
  const { width, height } = viewport;
  const { nodes, materials } = useGLTF("/scene.gltf");
  const { gl } = useThree();
  // const { toneMappingValue } = useControls({
  //   tone: {
  //     options: [
  //       "NoToneMapping",
  //       "LinearToneMapping",
  //       "ACESFilmicToneMapping",
  //       "ReinhardToneMapping",
  //       "CineonToneMapping",
  //     ],
  //     onChange: (e) => {
  //       const val = TONEMAPPING_DIC[e];
  //       gl.toneMapping = val;
  //     },
  //   },
  // });

  const resizeHandler = useCallback(() => {
    gl.toneMapping = NoToneMapping;
  }, [gl]);

  useEffect(() => {
    window.addEventListener("resize", resizeHandler);
    return () => {
      window.removeEventListener("resize", resizeHandler);
    };
  }, [resizeHandler]);

  const mouseMoveHandler = useCallback((event) => {
    const { clientX, clientY } = event;
    const normalizedX = (clientX / window.innerWidth) * 2 - 1;
    const normalizedY = (-clientY / window.innerHeight) * 2 + 1;
    gsap.to(sceneGroup.current.scale, {
      x: 1 - 0.03 * normalizedY,
      y: 1 - 0.03 * normalizedY,
      duration: MOVE_DURATION,
    });
    gsap.to(sceneGroup.current.position, {
      x: normalizedX * 0.2,
      duration: MOVE_DURATION,
    });
    gsap.to(sceneGroup.current.rotation, {
      x: -normalizedY * (Math.PI / 3) * 0.02,
      y: normalizedX * (Math.PI / 3) * 0.1,
      duration: MOVE_DURATION,
    });
  }, []);

  useEffect(() => {
    window.addEventListener("mousemove", mouseMoveHandler);
    return () => {
      window.removeEventListener("mousemove", mouseMoveHandler);
    };
  }, [mouseMoveHandler]);
  const fontSize = (width * 0.67) / 3;
  return (
    <>
      <group ref={sceneGroup} {...props} dispose={null}>
        <group rotation={[-Math.PI / 2, 0, 0]}>
          <group
            position={[0.34, 0, 0.41]}
            rotation={[0.54, -0.03, 0.38]}
            scale={0.9}
          >
            <mesh
              receiveShadow
              castShadow
              geometry={nodes.highlights_0.geometry}
              material={materials.highlights}
            />
          </group>
          <group
            position={[0.34, 0, 0.41]}
            rotation={[0.54, -0.03, 0.38]}
            scale={0.9}
          >
            <mesh
              receiveShadow
              castShadow
              geometry={nodes.eyes_0.geometry}
              material={materials["yeux.001"]}
            />
          </group>
          <group
            position={[0.34, 0, 0.41]}
            rotation={[0.54, -0.03, 0.38]}
            scale={0.9}
          >
            <mesh
              receiveShadow
              castShadow
              geometry={nodes.eyesnoir_0.geometry}
              material={materials.noir}
            />
          </group>
          <group
            position={[0.34, 0, 0.41]}
            rotation={[0.54, -0.03, 0.38]}
            scale={0.9}
          >
            <mesh
              receiveShadow
              castShadow
              geometry={nodes.eyescouleur_0.geometry}
              material={materials["yeux.couleur"]}
            />
          </group>
          <group
            position={[0.34, 0, 0.41]}
            rotation={[0.54, -0.03, 0.38]}
            scale={0.9}
          >
            <mesh
              receiveShadow
              castShadow
              geometry={nodes.defenses_0.geometry}
              material={materials.defenses}
            />
          </group>
          <mesh geometry={nodes.cyclo_0.geometry} material={materials.cyclo} />
          <group
            position={[0.34, 0, 0.41]}
            rotation={[0.54, -0.03, 0.38]}
            scale={0.9}
          >
            <mesh
              receiveShadow
              castShadow
              geometry={nodes.body_0.geometry}
              material={materials.peau}
            />
          </group>
        </group>
        <mesh position={[0, -0.001, 0]} rotation={[-Math.PI / 2, 0, 0]}>
          <planeBufferGeometry args={[50, 50]} />
          <meshBasicMaterial color={"#702b5e"} />
        </mesh>
        <mesh position={[0, 0, -4]}>
          <planeBufferGeometry args={[50, 50]} />
          <meshBasicMaterial color={"#662454"} />
        </mesh>
      </group>

      <Flex
        flexDirection="column"
        position-z={-3}
        position-y={5}
        position-x={0}
      >
        <Box width="auto">
          <Text font={fontUrl} fontSize={fontSize}>
            ELEPHANT
          </Text>
        </Box>
        <Flex
          position-y={-width * 0.2}
          position-x={-width * 0.4}
          justifyContent="space-between"
          flexDirection="row"
          width={width * 0.67}
        >
          <Box width="auto">
            <Text font={fontUrl} fontSize={fontSize}>
              LI'L
            </Text>
          </Box>
          <Box width="auto">
            <Text font={fontUrl} fontSize={fontSize}>
              BABY
            </Text>
          </Box>
        </Flex>
      </Flex>
    </>
  );
}

useGLTF.preload("/scene.gltf");

// TweenMax.to(i.scale, .5, {
//   x: 1 - .1 * t.y,
//   y: 1 - .1 * t.y
// }),
// TweenMax.to(i.position, .5, {
//   x: t.x
// }),
// TweenMax.to(i.rotation, .5, {
//   x: -t.y * (Math.PI / 3) * .1,
//   y: t.x * (Math.PI / 3) * .1
// })
